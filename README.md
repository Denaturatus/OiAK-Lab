# Organization and Architecture of Computers

## Lab2 - Addition, subtraction and multiplication on large numbers

First I learned about the assembly instructions for arithmetic operations involving carry flags.
In the case of addition and subtraction, the first simpler versions of programs were written that perform these operations on numbers of equal length. 
Then, the programs were extended with algorithms enabling addition and subtraction on numbers of different lengths. 
These programs are not very different from each other, the algorithms are the same, only the individual instructions change. 
In the case of multiplication, the program was written straight away with numbers of different lengths in mind. 
The `gdb` debugger was used during work. Thanks to this tool it was easy to find out if the programs behaved as it should. 
If the code generated wrong results, then `gdb` facilitated locating bugs (by displaying the contents of registers at chosen moments).

### Running the program

The program was assembled and linked using a makefile and the `make` command. 
You can get the results of the program as follows: turn on `gdb`:

```
gdb dodawanieWielkieLiczby
```

set breakpoint to the label `exit`, 
start going through the program and display the stack with the command `info stack`.

## Lab3 - Addition, subtraction, multiplication and division on single and double precision floating point numbers.

First I got acquainted with the `x87 FPU` - a floating point unit of the processor, 
and more precisely with its documentation and materials posted on the Internet. 
The idea of floating point operations is significantly different from that of fixed point operations. 
After constructing the subroutines responsible for individual operations, the precision and rounding modes were taken into account - for this, 
the control word had to be modified. 
The knowledge of what the control word should look like for a given precision and rounding mode was taken from the Intel documentation and tables included there. 
If you wanted to control the registers used during floating point operations, you had to use the extended debugger command `gdb`: `info all-r`. 
The last part of the work on the program was generating exceptions.

### Running the program

The program was assembled and linked using a makefile and the `make` command. 
You can get the results of the program as follows: turn on `gdb`:

```
gdb kalkulator 
```

set breakpoint to the label `exit`, 
start going through the program and display floating point registers with the command `info all-r`.

## Lab4 - Comparison of the execution time of basic arithmetic operations in SISD and SIMD architectures

At the beginning, I built the appropriate theoretical background. 
I collected and assimilated information about SISD and SIMD architectures, `SSE` instructions, `GCC` compiler, 
refreshed knowledge about `x87 FPU` processor floating point unit acquired during 3rd assignment and read about inline assembly in `C` language. 
Then I started to write functions that perform the required arithmetic operations (addition, subtraction , multiplication, division) using vectors (`SSE` instructions) and normal numbers (FPU instructions). 
After verifying the correctness of the results generated by the above-mentioned functions, 
I added a mechanism for measuring the execution time of individual steps of the algorithms. 
Lastly I wrote a function generating pseudo-random numbers filling vectors in the vector table 
and created a loop in the "main" responsible for performing measurements.

### Running the program

The program was compiled with the `GCC` compiler, makefile and the `make` command. 
Additionally, the `-o` option was used to determine a specific file name for the output.

```
248862_Lab_4
```
